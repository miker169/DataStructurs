{"version":3,"sources":["../Graph.js"],"names":["Graph","vertices","adjList","Map","addVertex","v","push","set","addEdge","w","get","toString","s","i","length","neighbors","j","initializeColor","color","bfs","queue","d","pred","enqueue","isEmpty","u","dequeue","neighbours","distances","predecessors","dfs","callback","dfsVisit","time","DFS","f","p","DFSVisit","discovery","finished","console","log","graph","myVertices","printNode","value"],"mappings":"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","file":"Graph.js","sourcesContent":["import {Queue} from './Queue';\nimport {Stack} from './Stack';\n\nfunction Graph() {\n    var vertices = []; //{1}\n    var adjList = new Map(); //{2}\n\n    this.addVertex = function (v) {\n        vertices.push(v); //{3}\n        adjList.set(v, []); //{4}\n    };\n\n    this.addEdge = function (v, w) {\n        adjList.get(v).push(w); //{5}\n        adjList.get(w).push(v); //{6}\n    };\n\n    this.toString = function () {\n        var s = '';\n        for (var i = 0; i < vertices.length; i++) { //{10}\n            s += vertices[i] + ' -> ';\n            var neighbors = adjList.get(vertices[i]); //{11}\n            for (var j = 0; j < neighbors.length; j++) { //{12}\n                s += neighbors[j] + ' ';\n            }\n            s += '\\n'; //{13}\n        }\n        return s;\n    };\n\n    var initializeColor = function () {\n        var color = [];\n        for (var i = 0; i < vertices.length; i++) {\n            color[vertices[i]] = 'white'; // All vertices have the color white\n        }\n        return color;\n    };\n\n    this.bfs = function (v) {\n        var color = initializeColor(),\n            queue = new Queue(),\n            d = [], // declare d which represents the distances\n            pred = []; // the predecessor array\n        queue.enqueue(v);\n\n        for (var i = 0; i < vertices.length; i++) { // loop through each vertice\n            d[vertices[i]] = 0;  // initialise distance to 0 for every vertice\n            pred[vertices[i]] = null; // initialize pred to 0 for each vertice\n        }\n\n        while (!queue.isEmpty()) {\n            var u = queue.dequeue();\n            let neighbours = adjList.get(u);\n            color[u] = 'grey';\n            for (i = 0; i < neighbours.length; i++) {\n                var w = neighbours[i];\n                if (color[w] === 'white') {\n                    color[w] = 'grey';\n                    d[w] = d[u] + 1;  // Increment the distance between w and u\n                    pred[w] = u; // set the pred of w as u\n                    queue.enqueue(w);\n                }\n            }\n            color[u] = 'black';\n        }\n        return {\n            distances: d,\n            predecessors: pred\n        };\n    };\n\n    this.dfs = function(callback) {\n        var color = initializeColor(); // Initialise the color array\n\n        for(var i = 0; i< vertices.length; i++){ // loop through vertices\n            if (color[vertices[i]] === 'white'){ // for each non visited\n                dfsVisit(vertices[i], color, callback); // call dfsVisit\n                // passing the vertex , color array and calback\n            }\n        }\n    };\n\n    var dfsVisit = function(u, color, callback) {\n        color[u] = 'grey'; // set the vertice as discovered\n        if(callback){\n            callback(u); // executre a callback here to say what we have\n            //visited\n        }\n\n        var neighbours = adjList.get(u); // get the neighbours of the vertix\n        for(var i = 0; i < neighbours.length; i++){ // for each neighbor\n            var w = neighbours[i];\n            if (color[w] === 'white'){ // set the vertex as visited\n                dfsVisit(w, color, callback); // recursively visit the children\n            }\n        }\n        color[u] = 'black'; // vertex is explored\n    };\n\n    var time = 0; // declare a variable for time\n    \n    this.DFS = function() {\n        var color = initializeColor(),\n            d = [],\n            f = [],\n            p = [], // declare d f and p arrays and intialise\n            time = 0;\n\n        for (var i = 0; i < vertices.length; i ++){\n            f[vertices[i]] = 0;// initialize d f and p for each vertix\n            d[vertices[i]] = 0;\n            p[vertices[i]] = null;\n        }\n\n        for (i = 0; i < vertices.length; i++){\n            if (color[vertices[i]] === 'white'){\n                DFSVisit(vertices[i], color, d, f, p);\n            }\n        }\n\n        return {\n            discovery: d, // return them to work with them later\n            finished: f,\n            predecessors: p\n        };\n    };\n\n    var DFSVisit = function(u, color, d, f, p){\n        console.log('discovered ' + u);\n        color[u] = 'grey';\n        d[u] = ++time; // when a vertex is first discovered track its discovery time\n        var neighbours = adjList.get(u);  //get the neighbours\n\n        for(var i = 0; i < neighbours.length; i++){\n            var w = neighbours[i];\n            if (color[w] === 'white'){ // for not visited vertices\n                p[w] = u; // set the predessor\n                DFSVisit(w, color, d, f, p);\n            }\n        }\n\n        color[u] = 'black';\n        f[u] = ++time; // track the finsished exploring time\n        console.log('explored ' + u);\n    };\n\n    // this.bfs = function (v, callback) {\n    //     var color = initializeColor(), // initialize color array with white\n    //         queue = new Queue(); // create new queue\n    //     queue.enqueue(v); // The vertex that is point of origin\n    //\n    //     while (!queue.isEmpty()) { // check if the queue is not empty\n    //         var u = queue.dequeue(); // remove vertex by dequeeing\n    //         let neigbours = adjList.get(u); // get the vertex's neigbours\n    //         color[u] = 'grey'; // mark vertex dequed as discovered (not explored)\n    //         for (var i = 0; i < neigbours.length; i++) { // loop thru each neighbour\n    //             var w = neigbours[i]; // get the value of the neighbours\n    //             if (color[w] === 'white') { // If not visited yet\n    //                 color[w] = 'grey'; // set it to discovered\n    //                 queue.enqueue(w); // add the vertex to the queue\n    //             }\n    //\n    //         }\n    //         color[u] = 'black'; // vertex can be marked as explored\n    //         if (callback) {\n    //             callback(u);\n    //         }\n    //     }\n    // };\n}\n\nvar graph = new Graph();\nvar myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']; //{7}\nfor (var i = 0; i < myVertices.length; i++) { //{8}\n    graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'B'); //{9}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\nfunction printNode(value) {\n    console.log('Visited vertex: ' + value);\n}\n\n//graph.bfs(myVertices[0], printNode);\n\n// var shoretestPathA = graph.bfs(myVertices[0]);\n// // console.log(shoretestPathA);\n//\n// var fromVertex = myVertices[0]; // Use vertice A as source vertex A\n//\n// for (var i = 1; i < myVertices.length; i++) { // for every other vertex except A\n//     // calculate the path from vertex A to it\n//\n//     var toVertex = myVertices[i], // get the vertice\n//         path = new Stack(); // create a stack to store the path\n//     for (var v = toVertex; v!== fromVertex;\n//     v=shoretestPathA.predecessors[v]) {\n//         console.log('toVertex', toVertex);\n//         console.log('predecessor', v);\n//         path.push(v);\n//         console.log('After push');\n//     }\n//     console.log('fromVertext', fromVertex);\n//     path.push(fromVertex);\n//     var s = path.pop();\n//     while(!path.isEmpty()){\n//         s += ' - ' + path.pop();\n//     }\n//     console.log(s);\n// }\ngraph.DFS(printNode);"]}